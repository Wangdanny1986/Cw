name: daily-checkin
on:
workflow_dispatch:
schedule:
- cron: "15 1 * * "
jobs:
run:
runs-on: ubuntu-latest
steps:
- uses: actions/setup-python@v5
with:
python-version: "3.11"
- run: pip install requests
- name: Run checkin
env:
ACCOUNTS: ${{ secrets.ACCOUNTS }}
TG_BOT_TOKEN: ${{ secrets.TG_BOT_TOKEN }}
TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
run: |
cat > checkin.py << 'PY'
import os, re, json, time, random, requests

GLOBAL_TG_BOT_TOKEN = os.getenv("TG_BOT_TOKEN")
GLOBAL_TG_CHAT_ID = os.getenv("TG_CHAT_ID")


def notify(msg, chat_id=None):
    print(msg)
    if GLOBAL_TG_BOT_TOKEN and (chat_id or GLOBAL_TG_CHAT_ID):
        try:
            requests.post(
                f"https://api.telegram.org/bot{GLOBAL_TG_BOT_TOKEN}/sendMessage",
                data={"chat_id": chat_id or GLOBAL_TG_CHAT_ID, "text": msg},
                timeout=20,
            )
        except Exception as e:
            print("TG 通知失败:", e)


def mask_email(email):
    if not email or "@" not in email:
        return "account"
    name, domain = email.split("@", 1)
    if len(name) <= 1:
        masked = "*"
    elif len(name) == 2:
        masked = name[0] + "*"
    else:
        masked = name[0] + "*" * (len(name) - 2) + name[-1]
    return f"{masked}@{domain}"


def label_for(acc):
    if acc.get("label"):
        return acc["label"]
    if acc.get("email"):
        return mask_email(acc["email"])
    return "account"


def looks_like_2fa_or_human(html_or_text):
    if not html_or_text:
        return False
    t = str(html_or_text).lower()
    keywords = [
        "two-factor",
        "2fa",
        "totp",
        "google authenticator",
        "verification code",
        "please verify you are human",
        "attention required",
        "cloudflare",
        "cf-chl",
        "captcha",
        "hcaptcha",
        "recaptcha",
        "verify your identity",
        "second factor",
    ]
    return any(k in t for k in keywords)


def v2_checkin(base, email, pwd):
    s = requests.Session()
    try:
        r = s.post(
            f"{base}/api/v1/passport/auth/login",
            json={"email": email, "password": pwd},
            timeout=30,
        )
    except Exception as e:
        return {"status": "failed", "detail": f"V2 请求异常: {e}"}
    if r.status_code != 200:
        txt = r.text[:200]
        if looks_like_2fa_or_human(txt):
            return {"status": "2fa", "detail": f"V2 登录被 2FA/人机验证拦截: {r.status_code}"}
        return {"status": "failed", "detail": f"V2 登录失败 {r.status_code}: {txt}"}
    if r.headers.get("content-type", "").startswith("application/json"):
        d = r.json()
    else:
        d = {}
    if looks_like_2fa_or_human(str(d)):
        return {"status": "2fa", "detail": "V2 登录需要 2FA/验证码"}
    token = (d.get("data") or {}).get("token") or d.get("token")
    if not token:
        return {"status": "failed", "detail": f"V2 无 token: {d}"}
    try:
        cr = s.post(
            f"{base}/api/v1/user/checkin",
            headers={"Authorization": f"Bearer {token}"},
            timeout=30,
        )
    except Exception as e:
        return {"status": "failed", "detail": f"V2 签到异常: {e}"}
    try:
        cj = cr.json()
    except Exception:
        cj = {"raw": cr.text[:200]}
    if cr.status_code == 200:
        msg = str(cj)
        if re.search(r"already|已签到|重复|signed", msg, re.I):
            return {"status": "already", "detail": f"V2 已签到: {cj}"}
        return {"status": "success", "detail": f"V2 成功: {cj}"}
    else:
        txt = str(cj)
        if looks_like_2fa_or_human(txt):
            return {"status": "2fa", "detail": f"V2 被 2FA/验证码拦截: {cr.status_code}"}
        return {"status": "failed", "detail": f"V2 失败 {cr.status_code}: {cj}"}


def extract_csrf(html):
    if not html:
        return None
    m = re.search(r'name=["\']csrf-token["\']\s+content=["\']([^"\']+)', html, re.I) \
        or re.search(r'csrfToken["\']\s*[:=]\s*["\']([^"\']+)', html, re.I) \
        or re.search(r'name=["\']_token["\']\s+value=["\']([^"\']+)', html, re.I)
    return m.group(1) if m else None


def sspanel_checkin(base, email, pwd):
    s = requests.Session()
    try:
        r = s.get(f"{base}/auth/login", timeout=30)
    except Exception as e:
        return {"status": "failed", "detail": f"SS 登录页异常: {e}"}
    if looks_like_2fa_or_human(r.text):
        return {"status": "2fa", "detail": "SS 登录页出现 2FA/人机验证"}
    csrf = extract_csrf(r.text) if r.ok else None
    headers = {"Referer": f"{base}/auth/login"}
    if csrf:
        headers["X-CSRF-Token"] = csrf
    try:
        lr = s.post(
            f"{base}/auth/login",
            data={"email": email, "passwd": pwd, "remember_me": "on", "code": ""},
            headers=headers,
            timeout=30,
            allow_redirects=True,
        )
    except Exception as e:
        return {"status": "failed", "detail": f"SS 登录异常: {e}"}
    if lr.status_code not in (200, 302):
        txt = lr.text[:200]
        if looks_like_2fa_or_human(txt):
            return {"status": "2fa", "detail": f"SS 登录被 2FA/人机验证拦截 {lr.status_code}"}
        return {"status": "failed", "detail": f"SS 登录失败 {lr.status_code}: {txt}"}
    try:
        ur = s.get(f"{base}/user", timeout=30)
    except Exception as e:
        return {"status": "failed", "detail": f"SS 访问/user异常: {e}"}
    if ur.status_code != 200:
        txt = ur.text[:200]
        if looks_like_2fa_or_human(txt):
            return {"status": "2fa", "detail": "SS 登录后遇到 2FA/人机验证"}
        return {"status": "failed", "detail": f"SS /user 失败 {ur.status_code}"}
    page_csrf = extract_csrf(ur.text) or csrf
    hh = {"Referer": f"{base}/user", "X-Requested-With": "XMLHttpRequest"}
    if page_csrf:
        hh["X-CSRF-Token"] = page_csrf
    try:
        cr = s.post(f"{base}/user/checkin", headers=hh, timeout=30)
    except Exception as e:
        return {"status": "failed", "detail": f"SS 签到异常: {e}"}
    try:
        cj = cr.json()
    except Exception:
        cj = {"raw": cr.text[:200]}
    if cr.status_code == 200:
        msg = str(cj)
        if re.search(r"already|已签到|重复|signed", msg, re.I):
            return {"status": "already", "detail": f"SS 已签到: {cj}"}
        return {"status": "success", "detail": f"SS 成功: {cj}"}
    else:
        txt = str(cj)
        if looks_like_2fa_or_human(txt):
            return {"status": "2fa", "detail": f"SS 被 2FA/验证码拦截: {cr.status_code}"}
        return {"status": "failed", "detail": f"SS 失败 {cr.status_code}: {cj}"}


def run_one(a, summary):
    base = (a.get("base_url") or "https://panel.freecloud.ltd").rstrip("/")
    email = a.get("email"); pwd = a.get("password"); chat = a.get("tg_chat_id")
    label = label_for(a)
    if not (email and pwd):
        notify(f"[{label}] 缺少邮箱/密码，跳过。", chat)
        summary["failed"].append(label)
        return
    notify(f"开始签到：[{label}] @ {base}", chat)
    r1 = v2_checkin(base, email, pwd)
    if r1["status"] == "success":
        notify(f"[{label}] -> {r1['detail']}", chat)
        summary["success"].append(label)
        return
    if r1["status"] == "already":
        notify(f"[{label}] -> {r1['detail']}", chat)
        summary["already"].append(label)
        return
    else:
        notify(f"[{label}] -> [V2 未成功] {r1['detail']}", chat)
    r2 = sspanel_checkin(base, email, pwd)
    if r2["status"] == "success":
        notify(f"[{label}] -> {r2['detail']}", chat)
        summary["success"].append(label)
        return
    if r2["status"] == "already":
        notify(f"[{label}] -> {r2['detail']}", chat)
        summary["already"].append(label)
        return
    if r1["status"] == "2fa" or r2["status"] == "2fa":
        notify(f"[{label}] -> 检测到 2FA/人机验证，未继续尝试。请切换为 Cookie 模式或提供 TOTP。", chat)
        summary["2fa"].append(label)
        return
    notify(f"[{label}] -> [SS 未成功] {r2['detail']}", chat)
    summary["failed"].append(label)


def main():
    delay = random.randint(0, 120) * 60
    if delay > 0:
        print(f"随机延迟启动: {delay} 秒"); time.sleep(delay)
    accs = []
    if os.getenv("ACCOUNTS"):
        try:
            j = json.loads(os.getenv("ACCOUNTS", "[]"))
            if isinstance(j, list):
                accs = j
        except Exception:
            pass
    if not accs:
        print("缺少 ACCOUNTS，退出。"); return
    summary = {"success": [], "already": [], "failed": [], "2fa": []}
    for i, a in enumerate(accs):
        run_one(a, summary)
        if i < len(accs) - 1:
            jitter = random.randint(5, 60); print(f"下一个账户等待: {jitter} 秒"); time.sleep(jitter)
    parts = []
    if summary["success"]:
        parts.append("成功: " + ", ".join(summary["success"]))
    if summary["already"]:
        parts.append("已签到: " + ", ".join(summary["already"]))
    if summary["2fa"]:
        parts.append("需2FA: " + ", ".join(summary["2fa"]))
    if summary["failed"]:
        parts.append("失败: " + ", ".join(summary["failed"]))
    advice = ""
    if summary["2fa"]:
        advice = "\n提示: 检测到 2FA 或人机验证，请切换为 Cookie 模式或提供 TOTP。"
    final_msg = "FreeCloud 签到汇总\n" + ("\n".join(parts) if parts else "无账户执行") + advice
    notify(final_msg)


if __name__ == "__main__":
    main()
PY
python checkin.py
